/********************************************************************
*
*	本文件是FKMMORPG的一部分。本文件版权归属FreeKnightDuzhi(王宏张)所有。
*	E-mail: duzhi5368@163.com
*	QQ: 	281862942
* 	
*	-----------------------------------------------------------------
*
*	文件名：	Layer2
*	作者：		FreeKnightDuzhi[ 王宏张 ]
*	文件说明：	
*
*	修改人:		
*	修改内容:
*********************************************************************/

#include "../../include/CommonBase/CommonBaseInsideHead.h"

//==================================================================================================================

namespace FK3DEngine
{
	//--------------------------------------------------------------------------------------------------------------

	struct al_table
	{
		short bits;
		short d;
	};

	static struct al_table alloc_0[] = {
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767} };

	static struct al_table alloc_1[] = {
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{3,-3},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},{10,-511},
		{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
		{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{3,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767},
		{2,0},{5,3},{7,5},{16,-32767} };

	static struct al_table alloc_2[] = {
		{4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
		{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
		{4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
		{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63} };

	static struct al_table alloc_3[] = {
		{4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
		{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
		{4,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},{9,-255},
		{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},{15,-16383},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63} };

	static struct al_table alloc_4[] = {
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
			{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
			{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
			{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
		{4,0},{5,3},{7,5},{3,-3},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},{8,-127},
			{9,-255},{10,-511},{11,-1023},{12,-2047},{13,-4095},{14,-8191},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{3,0},{5,3},{7,5},{10,9},{4,-7},{5,-15},{6,-31},{7,-63},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9},
		{2,0},{5,3},{7,5},{10,9}  };

	static int grp_3tab[32 * 3] = { 0, };   /* used: 27 */
	static int grp_5tab[128 * 3] = { 0, };  /* used: 125 */
	static int grp_9tab[1024 * 3] = { 0, }; /* used: 729 */

	//--------------------------------------------------------------------------------------------------------------
	void InitLayer2()
	{
		static float mulmul[27] = {
			0.0f , -2.0f/3.0f , 2.0f/3.0f ,
				2.0f/7.0f , 2.0f/15.0f , 2.0f/31.0f, 2.0f/63.0f , 2.0f/127.0f , 2.0f/255.0f ,
				2.0f/511.0f , 2.0f/1023.0f , 2.0f/2047.0f , 2.0f/4095.0f , 2.0f/8191.0f ,
				2.0f/16383.0f , 2.0f/32767.0f , 2.0f/65535.0f ,
				-4.0f/5.0f , -2.0f/5.0f , 2.0f/5.0f, 4.0f/5.0f ,
				-8.0f/9.0f , -4.0f/9.0f , -2.0f/9.0f , 2.0f/9.0f , 4.0f/9.0f , 8.0f/9.0f };
			static int base[3][9] = {
				{ 1 , 0, 2 , } ,
				{ 17, 18, 0 , 19, 20 , } ,
				{ 21, 1, 22, 23, 0, 24, 25, 2, 26 } };
				int i,j,k,l,len;
				float *table;
				static int tablen[3] = { 3 , 5 , 9 };
				static int *itable,*tables[3] = { grp_3tab , grp_5tab , grp_9tab };

				for(i=0;i<3;i++)
				{
					itable = tables[i];
					len = tablen[i];
					for(j=0;j<len;j++)
						for(k=0;k<len;k++)
							for(l=0;l<len;l++)
							{
								*itable++ = base[i][l];
								*itable++ = base[i][k];
								*itable++ = base[i][j];
							}
				}

				for(k=0;k<27;k++)
				{
					float m=mulmul[k];
					table = g_pMuls[k];
					for(j=3,i=0;i<63;i++,j--)
						*table++ = m * pow(2.0f,(float)j / 3.0f);
					*table++ = 0.0f;
				}
	}
	//--------------------------------------------------------------------------------------------------------------
	void II_step_one(unsigned int *bit_alloc,int *scale,MPEGFrameInfo* fr)
	{
		int stereo = fr->dwChannels-1;
		int sblimit = fr->nTableSelect;
		int jsbound = fr->nJointStereo;
		int sblimit2 = fr->nTableSelect<<stereo;
		struct al_table *alloc1 = (al_table*)fr->pTableAlloc;
		int i;
		static unsigned int scfsi_buf[64];
		unsigned int *scfsi,*bita;
		int sc,step;

		bita = bit_alloc;
		if(stereo)
		{
			for (i=jsbound;i;i--,alloc1+=(1<<step))
			{
				*bita++ = (char) GetBit(step=alloc1->bits);
				*bita++ = (char) GetBit(step);
			}
			for (i=sblimit-jsbound;i;i--,alloc1+=(1<<step))
			{
				bita[0] = (char) GetBit(step=alloc1->bits);
				bita[1] = bita[0];
				bita+=2;
			}
			bita = bit_alloc;
			scfsi=scfsi_buf;
			for (i=sblimit2;i;i--)
				if (*bita++)
					*scfsi++ = (char) GetBitFast(2);
		}
		else /* mono */
		{
			for (i=sblimit;i;i--,alloc1+=(1<<step))
				*bita++ = (char) GetBit(step=alloc1->bits);
			bita = bit_alloc;
			scfsi=scfsi_buf;
			for (i=sblimit;i;i--)
				if (*bita++)
					*scfsi++ = (char) GetBitFast(2);
		}

		bita = bit_alloc;
		scfsi=scfsi_buf;
		for (i=sblimit2;i;i--) 
			if (*bita++)
				switch (*scfsi++) 
			{
				case 0: 
					*scale++ = GetBitFast(6);
					*scale++ = GetBitFast(6);
					*scale++ = GetBitFast(6);
					break;
				case 1 : 
					*scale++ = sc = GetBitFast(6);
					*scale++ = sc;
					*scale++ = GetBitFast(6);
					break;
				case 2: 
					*scale++ = sc = GetBitFast(6);
					*scale++ = sc;
					*scale++ = sc;
					break;
				default:              /* case 3 */
					*scale++ = GetBitFast(6);
					*scale++ = sc = GetBitFast(6);
					*scale++ = sc;
					break;
			}

	}
	//--------------------------------------------------------------------------------------------------------------
	void II_step_two(unsigned int *bit_alloc,float fraction[2][4][MPEG_SBLimit],int *scale,MPEGFrameInfo* fr,int x1)
	{
		int i,j,k,ba;
		int stereo = fr->dwChannels;
		int sblimit = fr->nTableSelect;
		int jsbound = fr->nJointStereo;
		struct al_table *alloc2,*alloc1 = (al_table*)fr->pTableAlloc;
		unsigned int *bita=bit_alloc;
		int d1,step;

		for (i=0;i<jsbound;i++,alloc1+=(1<<step))
		{
			step = alloc1->bits;
			for (j=0;j<stereo;j++)
			{
				if ( (ba=*bita++) ) 
				{
					k=(alloc2 = alloc1+ba)->bits;
					if( (d1=alloc2->d) < 0) 
					{
						float cm=g_pMuls[k][scale[x1]];
						fraction[j][0][i] = ((float) ((int)GetBit(k) + d1)) * cm;
						fraction[j][1][i] = ((float) ((int)GetBit(k) + d1)) * cm;
						fraction[j][2][i] = ((float) ((int)GetBit(k) + d1)) * cm;
					}        
					else 
					{
						static int *table[] = { 0,0,0,grp_3tab,0,grp_5tab,0,0,0,grp_9tab };
						unsigned int idx,*tab,m=scale[x1];
						idx = (unsigned int) GetBit(k);
						tab = (unsigned int *) (table[d1] + idx + idx + idx);
						fraction[j][0][i] = g_pMuls[*tab++][m];
						fraction[j][1][i] = g_pMuls[*tab++][m];
						fraction[j][2][i] = g_pMuls[*tab][m];  
					}
					scale+=3;
				}
				else
					fraction[j][0][i] = fraction[j][1][i] = fraction[j][2][i] = 0.0f;
			}
		}

		for (i=jsbound;i<sblimit;i++,alloc1+=(1<<step))
		{
			step = alloc1->bits;
			bita++;	/* channel 1 and channel 2 bitalloc are the same */
			if ( (ba=*bita++) )
			{
				k=(alloc2 = alloc1+ba)->bits;
				if( (d1=alloc2->d) < 0)
				{
					float cm;
					cm=g_pMuls[k][scale[x1+3]];
					fraction[1][0][i] = (fraction[0][0][i] = (float) ((int)GetBit(k) + d1) ) * cm;
					fraction[1][1][i] = (fraction[0][1][i] = (float) ((int)GetBit(k) + d1) ) * cm;
					fraction[1][2][i] = (fraction[0][2][i] = (float) ((int)GetBit(k) + d1) ) * cm;
					cm=g_pMuls[k][scale[x1]];
					fraction[0][0][i] *= cm; fraction[0][1][i] *= cm; fraction[0][2][i] *= cm;
				}
				else
				{
					static int *table[] = { 0,0,0,grp_3tab,0,grp_5tab,0,0,0,grp_9tab };
					unsigned int idx,*tab,m1,m2;
					m1 = scale[x1]; m2 = scale[x1+3];
					idx = (unsigned int) GetBit(k);
					tab = (unsigned int *) (table[d1] + idx + idx + idx);
					fraction[0][0][i] = g_pMuls[*tab][m1]; fraction[1][0][i] = g_pMuls[*tab++][m2];
					fraction[0][1][i] = g_pMuls[*tab][m1]; fraction[1][1][i] = g_pMuls[*tab++][m2];
					fraction[0][2][i] = g_pMuls[*tab][m1]; fraction[1][2][i] = g_pMuls[*tab][m2];
				}
				scale+=6;
			}
			else {
				fraction[0][0][i] = fraction[0][1][i] = fraction[0][2][i] =
					fraction[1][0][i] = fraction[1][1][i] = fraction[1][2][i] = 0.0f;
			}
			/* 
			should we use individual scalefac for channel 2 or
			is the current way the right one , where we just copy channel 1 to
			channel 2 ?? 
			The current 'strange' thing is, that we throw away the scalefac
			values for the second channel ...!!
			-> changed .. now we use the scalefac values of channel one !! 
			*/
		}

		for(i=sblimit;i<MPEG_SBLimit;i++)
			for (j=0;j<stereo;j++)
				fraction[j][0][i] = fraction[j][1][i] = fraction[j][2][i] = 0.0f;

	}
	//--------------------------------------------------------------------------------------------------------------
	static void II_select_table(MPEGFrameInfo* fr)
	{
		static int translate[3][2][16] =
		{ { { 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 } ,
		{ 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 } } ,
		{ { 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 } ,
		{ 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 } } ,
		{ { 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 } ,
		{ 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 } } };

		int table;
		static struct al_table *tables[5] =
		{ alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
		static int sblims[5] = { 27 , 30 , 8, 12 , 30 };

		if( fr->bMpegVersion != 0 )
			table = 4;
		else
			table = translate[fr->nFreqIndex][2-fr->dwChannels][fr->nBitRateIndex];

		fr->pTableAlloc	= tables[table];
		fr->nTableSelect	= sblims[table];
	}
	//--------------------------------------------------------------------------------------------------------------
	int DecodeLayer2( MPEGFrameInfo* pFrameInfo, unsigned char* pOut, int* pOutSize )
	{
		int clip=0;
		int i,j;
		int stereo = pFrameInfo->dwChannels;
		float pFrameInfoaction[2][4][MPEG_SBLimit]; /* pick_table clears unused subbands */
		unsigned int bit_alloc[64];
		int scale[192];

		II_select_table(pFrameInfo);
		pFrameInfo->nJointStereo = (pFrameInfo->dwChannels == 1) ? (pFrameInfo->bJointMode<<2)+4 : pFrameInfo->nTableSelect;

		II_step_one(bit_alloc, scale, pFrameInfo);

		for (i=0;i<MPEG_ScaleBlock;i++) 
		{
			II_step_two(bit_alloc,pFrameInfoaction,scale,pFrameInfo,i>>2);
			for (j=0;j<3;j++)
			{
				if( stereo == 1 )
				{
					clip += Synth_1to1_Mono(pFrameInfoaction[0][j],pOut,pOutSize);
				}
				else
				{
					int p1 = *pOutSize;
					clip += Synth_1to1(pFrameInfoaction[0][j],0,pOut,&p1);
					clip += Synth_1to1(pFrameInfoaction[1][j],1,pOut,pOutSize);
				}
			}
		}

		return clip;
	}
	//--------------------------------------------------------------------------------------------------------------
}

//==================================================================================================================
